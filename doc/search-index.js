var searchIndex = {};
searchIndex['phf'] = {"items":[[0,"","phf","Compile time optimized maps and sets."],[8,"PhfHash","","A trait implemented by types which can be used in PHF data structures"],[10,"phf_hash","","Hashes the value of `self`, factoring in a seed",0],[3,"Map","","An immutable map constructed at compile time."],[3,"Set","","An immutable set constructed at compile time."],[3,"OrderedMap","","An order-preserving immutable map constructed at compile time."],[3,"OrderedSet","","An order-preserving immutable set constructed at compile time."],[0,"map","","An immutable map constructed at compile time."],[3,"Map","phf::map","An immutable map constructed at compile time."],[3,"Entries","","An iterator over the key/value pairs in a `Map`."],[3,"Keys","","An iterator over the keys in a `Map`."],[3,"Values","","An iterator over the values in a `Map`."],[11,"fmt","","",1],[6,"Output","",""],[11,"index","","",1],[11,"is_empty","","Returns true if the `Map` is empty.",1],[11,"len","","Returns the number of entries in the `Map`.",1],[11,"contains_key","","Determines if `key` is in the `Map`.",1],[11,"get","","Returns a reference to the value that `key` maps to.",1],[11,"get_key","","Returns a reference to the map's internal static instance of the given\nkey.",1],[11,"get_entry","","Like `get`, but returns both the key and the value.",1],[11,"entries","","Returns an iterator over the key/value pairs in the map.",1],[11,"keys","","Returns an iterator over the keys in the map.",1],[11,"values","","Returns an iterator over the values in the map.",1],[6,"IntoIter","",""],[6,"Item","",""],[11,"next","","",2],[11,"size_hint","","",2],[11,"next_back","","",2],[6,"Item","",""],[11,"next","","",3],[11,"size_hint","","",3],[11,"next_back","","",3],[6,"Item","",""],[11,"next","","",4],[11,"size_hint","","",4],[11,"next_back","","",4],[0,"set","phf","An immutable set constructed at compile time."],[3,"Set","phf::set","An immutable set constructed at compile time."],[3,"Iter","","An iterator over the values in a `Set`."],[11,"fmt","","",5],[11,"len","","Returns the number of elements in the `Set`.",5],[11,"is_empty","","Returns true if the `Set` contains no elements.",5],[11,"get_key","","Returns a reference to the set's internal static instance of the given\nkey.",5],[11,"contains","","Returns true if `value` is in the `Set`.",5],[11,"iter","","Returns an iterator over the values in the set.",5],[11,"is_disjoint","","Returns true if `other` shares no elements with `self`.",5],[11,"is_subset","","Returns true if `other` contains all values in `self`.",5],[11,"is_superset","","Returns true if `self` contains all values in `other`.",5],[6,"IntoIter","",""],[6,"Item","",""],[11,"next","","",6],[11,"size_hint","","",6],[11,"next_back","","",6],[0,"ordered_map","phf","An order-preserving immutable map constructed at compile time."],[3,"OrderedMap","phf::ordered_map","An order-preserving immutable map constructed at compile time."],[3,"Entries","","An iterator over the entries in a `OrderedMap`."],[3,"Keys","","An iterator over the keys in a `OrderedMap`."],[3,"Values","","An iterator over the values in a `OrderedMap`."],[11,"fmt","","",7],[6,"Output","",""],[11,"index","","",7],[11,"len","","Returns the number of entries in the `Map`.",7],[11,"is_empty","","Returns true if the `Map` is empty.",7],[11,"get","","Returns a reference to the value that `key` maps to.",7],[11,"get_key","","Returns a reference to the map's internal static instance of the given\nkey.",7],[11,"contains_key","","Determines if `key` is in the `Map`.",7],[11,"get_index","","Returns the index of the key within the list used to initialize\nthe ordered map.",7],[11,"get_entry","","Like `get`, but returns both the key and the value.",7],[11,"entries","","Returns an iterator over the key/value pairs in the map.",7],[11,"keys","","Returns an iterator over the keys in the map.",7],[11,"values","","Returns an iterator over the values in the map.",7],[6,"IntoIter","",""],[6,"Item","",""],[11,"next","","",8],[11,"size_hint","","",8],[11,"next_back","","",8],[11,"indexable","","",8],[11,"idx","","",8],[6,"Item","",""],[11,"next","","",9],[11,"size_hint","","",9],[11,"next_back","","",9],[11,"indexable","","",9],[11,"idx","","",9],[6,"Item","",""],[11,"next","","",10],[11,"size_hint","","",10],[11,"next_back","","",10],[11,"indexable","","",10],[11,"idx","","",10],[0,"ordered_set","phf","An order-preserving immutable set constructed at compile time."],[3,"OrderedSet","phf::ordered_set","An order-preserving immutable set constructed at compile time."],[3,"Iter","","An iterator over the values in a `OrderedSet`."],[11,"fmt","","",11],[11,"len","","Returns the number of elements in the `OrderedSet`.",11],[11,"is_empty","","Returns true if the `OrderedSet` contains no elements.",11],[11,"get_key","","Returns a reference to the set's internal static instance of the given\nkey.",11],[11,"get_index","","Returns the index of the key within the list used to initialize\nthe ordered set.",11],[11,"contains","","Returns true if `value` is in the `Set`.",11],[11,"iter","","Returns an iterator over the values in the set.",11],[11,"is_disjoint","","Returns true if `other` shares no elements with `self`.",11],[11,"is_subset","","Returns true if `other` contains all values in `self`.",11],[11,"is_superset","","Returns true if `self` contains all values in `other`.",11],[6,"IntoIter","",""],[6,"Item","",""],[11,"next","","",12],[11,"size_hint","","",12],[11,"next_back","","",12],[11,"indexable","","",12],[11,"idx","","",12],[11,"pad_integral","core::fmt","Performs the correct padding for an integer which has already been\nemitted into a str. The str should *not* contain the sign for the\ninteger, that will be added by this method.",13],[11,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",13],[11,"write_str","","Writes some data to the underlying buffer contained within this\nformatter.",13],[11,"write_fmt","","Writes some formatted information into this instance",13],[11,"flags","","Flags for formatting (packed version of rt::Flag)",13],[11,"fill","","Character used as 'fill' whenever there is alignment",13],[11,"align","","Flag indicating what form of alignment was requested",13],[11,"width","","Optionally specified integer width that the output should be",13],[11,"precision","","Optionally specified precision for numeric types",13],[11,"fmt","core::num","",14],[11,"eq","","",14],[11,"ne","","",14],[11,"ne","","",14],[11,"eq","","",15],[11,"ne","","",15],[11,"ne","","",15],[11,"clone","","",15],[11,"clone_from","","",15],[11,"fmt","","",15],[11,"eq","","",16],[11,"ne","","",16],[11,"ne","","",16],[11,"clone","","",16],[11,"clone_from","","",16],[11,"fmt","","",16],[11,"fmt","","",15],[11,"description","","",15],[11,"cause","","",15],[11,"eq","","",17],[11,"ne","","",17],[11,"ne","","",17],[11,"clone","","",17],[11,"clone_from","","",17],[11,"fmt","","",17],[11,"eq","","",18],[11,"ne","","",18],[11,"ne","","",18],[11,"clone","","",18],[11,"clone_from","","",18],[11,"fmt","","",18],[11,"fmt","","",17],[11,"description","","",17],[11,"cause","","",17],[11,"hash","core::nonzero","",19],[11,"fmt","","",19],[11,"partial_cmp","","",19],[11,"lt","","",19],[11,"le","","",19],[11,"gt","","",19],[11,"ge","","",19],[11,"lt","","",19],[11,"le","","",19],[11,"gt","","",19],[11,"ge","","",19],[11,"cmp","","",19],[11,"eq","","",19],[11,"ne","","",19],[11,"ne","","",19],[11,"assert_receiver_is_total_eq","","",19],[11,"clone","","",19],[11,"clone_from","","",19],[11,"new","","Create an instance of NonZero with the provided value.\nYou must indeed ensure that the value is actually \"non-zero\".",19],[11,"deref","","",19],[11,"null","core::ptr","Returns a null Unique.",20],[11,"offset","","Return an (unsafe) pointer into the memory owned by `self`.",20],[11,"cmp","core::marker","",21],[11,"partial_cmp","","",21],[11,"lt","","",21],[11,"le","","",21],[11,"gt","","",21],[11,"ge","","",21],[11,"lt","","",21],[11,"le","","",21],[11,"gt","","",21],[11,"ge","","",21],[11,"assert_receiver_is_total_eq","","",21],[11,"eq","","",21],[11,"ne","","",21],[11,"ne","","",21],[11,"clone","","",21],[11,"clone_from","","",21],[11,"cmp","","",22],[11,"partial_cmp","","",22],[11,"lt","","",22],[11,"le","","",22],[11,"gt","","",22],[11,"ge","","",22],[11,"lt","","",22],[11,"le","","",22],[11,"gt","","",22],[11,"ge","","",22],[11,"assert_receiver_is_total_eq","","",22],[11,"eq","","",22],[11,"ne","","",22],[11,"ne","","",22],[11,"clone","","",22],[11,"clone_from","","",22],[11,"cmp","","",23],[11,"partial_cmp","","",23],[11,"lt","","",23],[11,"le","","",23],[11,"gt","","",23],[11,"ge","","",23],[11,"lt","","",23],[11,"le","","",23],[11,"gt","","",23],[11,"ge","","",23],[11,"assert_receiver_is_total_eq","","",23],[11,"eq","","",23],[11,"ne","","",23],[11,"ne","","",23],[11,"clone","","",23],[11,"clone_from","","",23],[11,"cmp","","",24],[11,"partial_cmp","","",24],[11,"lt","","",24],[11,"le","","",24],[11,"gt","","",24],[11,"ge","","",24],[11,"lt","","",24],[11,"le","","",24],[11,"gt","","",24],[11,"ge","","",24],[11,"assert_receiver_is_total_eq","","",24],[11,"eq","","",24],[11,"ne","","",24],[11,"ne","","",24],[11,"clone","","",24],[11,"clone_from","","",24],[11,"cmp","","",25],[11,"partial_cmp","","",25],[11,"lt","","",25],[11,"le","","",25],[11,"gt","","",25],[11,"ge","","",25],[11,"lt","","",25],[11,"le","","",25],[11,"gt","","",25],[11,"ge","","",25],[11,"assert_receiver_is_total_eq","","",25],[11,"eq","","",25],[11,"ne","","",25],[11,"ne","","",25],[11,"clone","","",25],[11,"clone_from","","",25],[11,"cmp","","",26],[11,"partial_cmp","","",26],[11,"lt","","",26],[11,"le","","",26],[11,"gt","","",26],[11,"ge","","",26],[11,"lt","","",26],[11,"le","","",26],[11,"gt","","",26],[11,"ge","","",26],[11,"assert_receiver_is_total_eq","","",26],[11,"eq","","",26],[11,"ne","","",26],[11,"ne","","",26],[11,"clone","","",26],[11,"clone_from","","",26],[11,"cmp","","",27],[11,"partial_cmp","","",27],[11,"lt","","",27],[11,"le","","",27],[11,"gt","","",27],[11,"ge","","",27],[11,"lt","","",27],[11,"le","","",27],[11,"gt","","",27],[11,"ge","","",27],[11,"assert_receiver_is_total_eq","","",27],[11,"eq","","",27],[11,"ne","","",27],[11,"ne","","",27],[11,"clone","","",27],[11,"clone_from","","",27],[11,"cmp","","",28],[11,"partial_cmp","","",28],[11,"lt","","",28],[11,"le","","",28],[11,"gt","","",28],[11,"ge","","",28],[11,"lt","","",28],[11,"le","","",28],[11,"gt","","",28],[11,"ge","","",28],[11,"assert_receiver_is_total_eq","","",28],[11,"eq","","",28],[11,"ne","","",28],[11,"ne","","",28],[11,"clone","","",28],[11,"clone_from","","",28],[11,"cmp","","",29],[11,"partial_cmp","","",29],[11,"lt","","",29],[11,"le","","",29],[11,"gt","","",29],[11,"ge","","",29],[11,"lt","","",29],[11,"le","","",29],[11,"gt","","",29],[11,"ge","","",29],[11,"assert_receiver_is_total_eq","","",29],[11,"eq","","",29],[11,"ne","","",29],[11,"ne","","",29],[11,"clone","","",29],[11,"clone_from","","",29],[11,"assert_receiver_is_total_eq","core::ops","",30],[11,"eq","","",30],[11,"ne","","",30],[11,"ne","","",30],[11,"clone","","",30],[11,"clone_from","","",30],[11,"fmt","","",30],[11,"assert_receiver_is_total_eq","","",31],[11,"eq","","",31],[11,"ne","","",31],[11,"ne","","",31],[11,"clone","","",31],[11,"clone_from","","",31],[11,"fmt","","",31],[11,"assert_receiver_is_total_eq","","",32],[11,"eq","","",32],[11,"ne","","",32],[11,"ne","","",32],[11,"clone","","",32],[11,"clone_from","","",32],[11,"fmt","","",32],[11,"assert_receiver_is_total_eq","","",33],[11,"eq","","",33],[11,"ne","","",33],[11,"ne","","",33],[11,"clone","","",33],[11,"clone_from","","",33],[11,"fmt","","",33],[11,"fmt","core::cmp","",34],[11,"eq","","",34],[11,"ne","","",34],[11,"ne","","",34],[11,"clone","","",34],[11,"clone_from","","",34],[11,"reverse","","Reverse the `Ordering`, so that `Less` becomes `Greater` and\nvice versa.",34],[11,"assert_receiver_is_total_eq","","",34],[11,"cmp","","",34],[11,"partial_cmp","","",34],[11,"lt","","",34],[11,"le","","",34],[11,"gt","","",34],[11,"ge","","",34],[11,"is","phf::core","Returns true if the boxed type is the same as `T`",35],[11,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",35],[11,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",35],[11,"hash","core::any","",36],[11,"fmt","","",36],[11,"assert_receiver_is_total_eq","","",36],[11,"eq","","",36],[11,"ne","","",36],[11,"ne","","",36],[11,"clone","","",36],[11,"clone_from","","",36],[11,"of","","Returns the `TypeId` of the type this generic function has been\ninstantiated with",36],[11,"new","core::atomic","Creates a new `AtomicBool`.",37],[11,"load","","Loads a value from the bool.",37],[11,"store","","Stores a value into the bool.",37],[11,"swap","","Stores a value into the bool, returning the old value.",37],[11,"compare_and_swap","","Stores a value into the bool if the current value is the same as the expected value.",37],[11,"fetch_and","","Logical \"and\" with a boolean value.",37],[11,"fetch_nand","","Logical \"nand\" with a boolean value.",37],[11,"fetch_or","","Logical \"or\" with a boolean value.",37],[11,"fetch_xor","","Logical \"xor\" with a boolean value.",37],[11,"new","","Creates a new `AtomicIsize`.",38],[11,"load","","Loads a value from the isize.",38],[11,"store","","Stores a value into the isize.",38],[11,"swap","","Stores a value into the isize, returning the old value.",38],[11,"compare_and_swap","","Stores a value into the isize if the current value is the same as the expected value.",38],[11,"fetch_add","","Add an isize to the current value, returning the previous value.",38],[11,"fetch_sub","","Subtract an isize from the current value, returning the previous value.",38],[11,"fetch_and","","Bitwise and with the current isize, returning the previous value.",38],[11,"fetch_or","","Bitwise or with the current isize, returning the previous value.",38],[11,"fetch_xor","","Bitwise xor with the current isize, returning the previous value.",38],[11,"new","","Creates a new `AtomicUsize`.",39],[11,"load","","Loads a value from the usize.",39],[11,"store","","Stores a value into the usize.",39],[11,"swap","","Stores a value into the usize, returning the old value.",39],[11,"compare_and_swap","","Stores a value into the usize if the current value is the same as the expected value.",39],[11,"fetch_add","","Add to the current usize, returning the previous value.",39],[11,"fetch_sub","","Subtract from the current usize, returning the previous value.",39],[11,"fetch_and","","Bitwise and with the current usize, returning the previous value.",39],[11,"fetch_or","","Bitwise or with the current usize, returning the previous value.",39],[11,"fetch_xor","","Bitwise xor with the current usize, returning the previous value.",39],[11,"new","","Creates a new `AtomicPtr`.",40],[11,"load","","Loads a value from the pointer.",40],[11,"store","","Stores a value into the pointer.",40],[11,"swap","","Stores a value into the pointer, returning the old value.",40],[11,"compare_and_swap","","Stores a value into the pointer if the current value is the same as the expected value.",40],[11,"new","","",41],[11,"load","","",41],[11,"store","","",41],[11,"swap","","",41],[11,"compare_and_swap","","",41],[11,"fetch_add","","",41],[11,"fetch_sub","","",41],[11,"fetch_and","","",41],[11,"fetch_or","","",41],[11,"fetch_xor","","",41],[11,"new","","",42],[11,"load","","",42],[11,"store","","",42],[11,"swap","","",42],[11,"compare_and_swap","","",42],[11,"fetch_add","","",42],[11,"fetch_sub","","",42],[11,"fetch_and","","",42],[11,"fetch_or","","",42],[11,"fetch_xor","","",42],[11,"into_cow","core::borrow","",43],[11,"clone","","",43],[11,"clone_from","","",43],[11,"to_mut","","Acquire a mutable reference to the owned form of the data.",43],[11,"into_owned","","Extract the owned data.",43],[11,"is_borrowed","","Returns true if this `Cow` wraps a borrowed value",43],[11,"is_owned","","Returns true if this `Cow` wraps an owned value",43],[11,"deref","","",43],[11,"assert_receiver_is_total_eq","","",43],[11,"cmp","","",43],[11,"eq","","",43],[11,"ne","","",43],[11,"partial_cmp","","",43],[11,"lt","","",43],[11,"le","","",43],[11,"gt","","",43],[11,"ge","","",43],[11,"fmt","","",43],[11,"fmt","","",43],[11,"new","core::cell","Creates a new `Cell` containing the given value.",44],[11,"get","","Returns a copy of the contained value.",44],[11,"set","","Sets the contained value.",44],[11,"as_unsafe_cell","","Get a reference to the underlying `UnsafeCell`.",44],[11,"clone","","",44],[11,"clone_from","","",44],[11,"default","","",44],[11,"eq","","",44],[11,"ne","","",44],[11,"fmt","","",45],[11,"eq","","",45],[11,"ne","","",45],[11,"ne","","",45],[11,"clone","","",45],[11,"clone_from","","",45],[11,"new","","Creates a new `RefCell` containing `value`.",46],[11,"into_inner","","Consumes the `RefCell`, returning the wrapped value.",46],[11,"borrow_state","","Query the current state of this `RefCell`",46],[11,"try_borrow","","Attempts to immutably borrow the wrapped value.",46],[11,"borrow","","Immutably borrows the wrapped value.",46],[11,"try_borrow_mut","","Mutably borrows the wrapped value.",46],[11,"borrow_mut","","Mutably borrows the wrapped value.",46],[11,"as_unsafe_cell","","Get a reference to the underlying `UnsafeCell`.",46],[11,"clone","","",46],[11,"clone_from","","",46],[11,"default","","",46],[11,"eq","","",46],[11,"ne","","",46],[11,"drop","","",47],[11,"clone","","",47],[11,"clone_from","","",47],[11,"deref","","",48],[11,"drop","","",49],[11,"deref","","",50],[11,"deref_mut","","",50],[11,"new","","Construct a new instance of `UnsafeCell` which will wrap the specified\nvalue.",51],[11,"get","","Gets a mutable pointer to the wrapped value.",51],[11,"into_inner","","Unwraps the value",51],[11,"clone","core::char","",52],[11,"clone_from","","",52],[11,"clone","","",53],[11,"clone_from","","",53],[11,"next","","",52],[11,"size_hint","","",52],[11,"clone","","",54],[11,"clone_from","","",54],[11,"clone","","",55],[11,"clone_from","","",55],[11,"next","","",54],[11,"size_hint","","",54],[11,"drop","core::finally","",56],[11,"len","core::iter","",57],[11,"len","","",58],[11,"len","","",59],[11,"len","","",60],[11,"len","","",61],[11,"clone","","",59],[11,"clone_from","","",59],[11,"next","","",59],[11,"size_hint","","",59],[11,"size_hint","","",59],[11,"next_back","","",59],[11,"indexable","","",59],[11,"idx","","",59],[11,"fmt","","",62],[11,"eq","","",62],[11,"ne","","",62],[11,"ne","","",62],[11,"clone","","",62],[11,"clone_from","","",62],[11,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",62],[11,"clone","","",63],[11,"clone_from","","",63],[11,"next","","",63],[11,"size_hint","","",63],[11,"size_hint","","",63],[11,"next_back","","",63],[11,"len","","",63],[11,"clone","","",64],[11,"clone_from","","",64],[11,"next","","",64],[11,"size_hint","","",64],[11,"size_hint","","",64],[11,"indexable","","",64],[11,"idx","","",64],[11,"clone","","",65],[11,"clone_from","","",65],[11,"next","","",65],[11,"size_hint","","",65],[11,"size_hint","","",65],[11,"next_back","","",65],[11,"indexable","","",65],[11,"idx","","",65],[11,"clone","","",61],[11,"clone_from","","",61],[11,"next","","",61],[11,"size_hint","","",61],[11,"size_hint","","",61],[11,"next_back","","",61],[11,"indexable","","",61],[11,"idx","","",61],[11,"clone","","",60],[11,"clone_from","","",60],[11,"next","","",60],[11,"size_hint","","",60],[11,"size_hint","","",60],[11,"next_back","","",60],[11,"indexable","","",60],[11,"idx","","",60],[11,"clone","","",66],[11,"clone_from","","",66],[11,"next","","",66],[11,"size_hint","","",66],[11,"size_hint","","",66],[11,"next_back","","",66],[11,"clone","","",67],[11,"clone_from","","",67],[11,"next","","",67],[11,"size_hint","","",67],[11,"size_hint","","",67],[11,"next_back","","",67],[11,"clone","","",57],[11,"clone_from","","",57],[11,"next","","",57],[11,"size_hint","","",57],[11,"size_hint","","",57],[11,"next_back","","",57],[11,"indexable","","",57],[11,"idx","","",57],[11,"clone","","",68],[11,"clone_from","","",68],[11,"next","","",68],[11,"size_hint","","",68],[11,"size_hint","","",68],[11,"len","","",68],[11,"peek","","Return a reference to the next element of the iterator with out\nadvancing it, or None if the iterator is exhausted.",68],[11,"is_empty","","Check whether peekable iterator is empty or not.",68],[11,"clone","","",69],[11,"clone_from","","",69],[11,"next","","",69],[11,"size_hint","","",69],[11,"size_hint","","",69],[11,"clone","","",70],[11,"clone_from","","",70],[11,"next","","",70],[11,"size_hint","","",70],[11,"size_hint","","",70],[11,"clone","","",71],[11,"clone_from","","",71],[11,"next","","",71],[11,"size_hint","","",71],[11,"size_hint","","",71],[11,"indexable","","",71],[11,"idx","","",71],[11,"len","","",71],[11,"clone","","",72],[11,"clone_from","","",72],[11,"next","","",72],[11,"size_hint","","",72],[11,"size_hint","","",72],[11,"indexable","","",72],[11,"idx","","",72],[11,"len","","",72],[11,"clone","","",73],[11,"clone_from","","",73],[11,"next","","",73],[11,"size_hint","","",73],[11,"size_hint","","",73],[11,"clone","","",74],[11,"clone_from","","",74],[11,"next","","",74],[11,"size_hint","","",74],[11,"size_hint","","",74],[11,"next_back","","",74],[11,"clone","","",75],[11,"clone_from","","",75],[11,"next","","",75],[11,"size_hint","","",75],[11,"size_hint","","",75],[11,"next_back","","",75],[11,"indexable","","",75],[11,"idx","","",75],[11,"len","","",75],[11,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",75],[11,"clone","","",58],[11,"clone_from","","",58],[11,"next","","",58],[11,"size_hint","","",58],[11,"size_hint","","",58],[11,"next_back","","",58],[11,"indexable","","",58],[11,"idx","","",58],[11,"clone","","",76],[11,"clone_from","","",76],[11,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the closure",76],[11,"next","","",76],[11,"size_hint","","",76],[11,"size_hint","","",76],[11,"clone","","",77],[11,"clone_from","","",77],[11,"next","","",77],[11,"size_hint","","",77],[11,"size_hint","","",77],[11,"clone","","",78],[11,"clone_from","","",78],[11,"next","","",78],[11,"size_hint","","",78],[11,"size_hint","","",78],[11,"next_back","","",78],[11,"clone","","",79],[11,"clone_from","","",79],[11,"next","","",79],[11,"size_hint","","",79],[11,"size_hint","","",79],[11,"next_back","","",79],[11,"clone","","",80],[11,"clone_from","","",80],[11,"next","","",80],[11,"size_hint","","",80],[11,"clone","","",81],[11,"clone_from","","",81],[11,"next","","",81],[11,"size_hint","","",81],[11,"next","core::ops","",31],[11,"size_hint","","",31],[11,"size_hint","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"len","","",31],[11,"next_back","","",31],[11,"next","","",32],[11,"size_hint","","",32],[11,"clone","core::iter","",82],[11,"clone_from","","",82],[11,"next","","",82],[11,"size_hint","","",82],[11,"size_hint","","",82],[11,"next_back","","",82],[11,"indexable","","",82],[11,"idx","","",82],[11,"hash","core::option","",83],[11,"fmt","","",83],[11,"cmp","","",83],[11,"assert_receiver_is_total_eq","","",83],[11,"partial_cmp","","",83],[11,"lt","","",83],[11,"le","","",83],[11,"gt","","",83],[11,"ge","","",83],[11,"lt","","",83],[11,"le","","",83],[11,"gt","","",83],[11,"ge","","",83],[11,"eq","","",83],[11,"ne","","",83],[11,"ne","","",83],[11,"clone","","",83],[11,"clone_from","","",83],[11,"is_some","","Returns `true` if the option is a `Some` value",83],[11,"is_none","","Returns `true` if the option is a `None` value",83],[11,"as_ref","","Convert from `Option<T>` to `Option<&T>`",83],[11,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",83],[11,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",83],[11,"expect","","Unwraps an option, yielding the content of a `Some`",83],[11,"unwrap","","Returns the inner `T` of a `Some(T)`.",83],[11,"unwrap_or","","Returns the contained value or a default.",83],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",83],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",83],[11,"map_or","","Applies a function to the contained value or returns a default.",83],[11,"map_or_else","","Applies a function to the contained value or computes a default.",83],[11,"ok_or","","Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err)`.",83],[11,"ok_or_else","","Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err())`.",83],[11,"iter","","Returns an iterator over the possibly contained value.",83],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",83],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",83],[11,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",83],[11,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",83],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",83],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",83],[11,"take","","Takes the value out of the option, leaving a `None` in its place.",83],[11,"cloned","","Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\nUseful for converting an Option<&T> to an Option<T>.",83],[11,"unwrap_or_default","","Returns the contained value or a default",83],[11,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",83],[11,"default","","",83],[11,"clone","","",84],[11,"clone_from","","",84],[11,"next","","",84],[11,"size_hint","","",84],[11,"size_hint","","",84],[11,"next_back","","",84],[11,"len","","",84],[11,"next","","",85],[11,"size_hint","","",85],[11,"size_hint","","",85],[11,"next_back","","",85],[11,"len","","",85],[11,"clone","","",85],[11,"clone_from","","",85],[11,"next","","",86],[11,"size_hint","","",86],[11,"size_hint","","",86],[11,"next_back","","",86],[11,"len","","",86],[11,"next","","",87],[11,"size_hint","","",87],[11,"size_hint","","",87],[11,"next_back","","",87],[11,"len","","",87],[11,"from_iter","","Takes each element in the `Iterator`: if it is `None`, no further\nelements are taken, and the `None` is returned. Should no `None` occur, a\ncontainer with the values of each `Option` is returned.",83],[11,"hash","core::result","",88],[11,"fmt","","",88],[11,"cmp","","",88],[11,"assert_receiver_is_total_eq","","",88],[11,"partial_cmp","","",88],[11,"lt","","",88],[11,"le","","",88],[11,"gt","","",88],[11,"ge","","",88],[11,"lt","","",88],[11,"le","","",88],[11,"gt","","",88],[11,"ge","","",88],[11,"eq","","",88],[11,"ne","","",88],[11,"ne","","",88],[11,"clone","","",88],[11,"clone_from","","",88],[11,"is_ok","","Returns true if the result is `Ok`",88],[11,"is_err","","Returns true if the result is `Err`",88],[11,"ok","","Convert from `Result<T, E>` to `Option<T>`",88],[11,"err","","Convert from `Result<T, E>` to `Option<E>`",88],[11,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",88],[11,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",88],[11,"as_mut_slice","","Convert from `Result<T, E>` to `&mut [T]` (without copying)",88],[11,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",88],[11,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",88],[11,"iter","","Returns an iterator over the possibly contained value.",88],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",88],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",88],[11,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",88],[11,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",88],[11,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",88],[11,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",88],[11,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",88],[11,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",88],[11,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",88],[11,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",88],[11,"as_slice","","Convert from `Result<T, E>` to `&[T]` (without copying)",88],[11,"next","","",89],[11,"size_hint","","",89],[11,"size_hint","","",89],[11,"next_back","","",89],[11,"len","","",89],[11,"clone","","",89],[11,"clone_from","","",89],[11,"next","","",90],[11,"size_hint","","",90],[11,"size_hint","","",90],[11,"next_back","","",90],[11,"len","","",90],[11,"next","","",91],[11,"size_hint","","",91],[11,"size_hint","","",91],[11,"next_back","","",91],[11,"len","","",91],[11,"from_iter","","Takes each element in the `Iterator`: if it is an `Err`, no further\nelements are taken, and the `Err` is returned. Should no `Err` occur, a\ncontainer with the values of each `Result` is returned.",88],[11,"fmt","core::simd","",92],[11,"fmt","","",93],[11,"fmt","","",94],[11,"fmt","","",95],[11,"fmt","","",96],[11,"fmt","","",97],[11,"fmt","","",98],[11,"fmt","","",99],[11,"fmt","","",100],[11,"fmt","","",101],[11,"index","core::slice","",102],[11,"index","","",102],[11,"index","","",102],[11,"index","","",102],[11,"as_slice","","View the underlying data as a subslice of the original data.",102],[11,"next","","",102],[11,"size_hint","","",102],[11,"size_hint","","",102],[11,"next_back","","",102],[11,"len","","",102],[11,"clone","","",102],[11,"clone_from","","",102],[11,"indexable","","",102],[11,"idx","","",102],[11,"index","","",103],[11,"index","","",103],[11,"index","","",103],[11,"index","","",103],[11,"index_mut","","",103],[11,"index_mut","","",103],[11,"index_mut","","",103],[11,"index_mut","","",103],[11,"into_slice","","View the underlying data as a subslice of the original data.",103],[11,"next","","",103],[11,"size_hint","","",103],[11,"size_hint","","",103],[11,"next_back","","",103],[11,"len","","",103],[11,"clone","","",104],[11,"clone_from","","",104],[11,"next","","",104],[11,"size_hint","","",104],[11,"size_hint","","",104],[11,"next_back","","",104],[11,"finish","","",104],[11,"finish","","",105],[11,"next","","",105],[11,"size_hint","","",105],[11,"size_hint","","",105],[11,"next_back","","",105],[11,"next","","",106],[11,"size_hint","","",106],[11,"size_hint","","",106],[11,"next","","",107],[11,"size_hint","","",107],[11,"size_hint","","",107],[11,"next","","",108],[11,"size_hint","","",108],[11,"size_hint","","",108],[11,"next","","",109],[11,"size_hint","","",109],[11,"size_hint","","",109],[11,"next","","",110],[11,"size_hint","","",110],[11,"size_hint","","",110],[11,"clone","","",111],[11,"clone_from","","",111],[11,"next","","",111],[11,"size_hint","","",111],[11,"size_hint","","",111],[11,"next_back","","",111],[11,"len","","",111],[11,"indexable","","",111],[11,"idx","","",111],[11,"clone","","",112],[11,"clone_from","","",112],[11,"next","","",112],[11,"size_hint","","",112],[11,"size_hint","","",112],[11,"next_back","","",112],[11,"len","","",112],[11,"indexable","","",112],[11,"idx","","",112],[11,"next","","",113],[11,"size_hint","","",113],[11,"size_hint","","",113],[11,"next_back","","",113],[11,"len","","",113],[11,"eq","core::str","",114],[11,"ne","","",114],[11,"ne","","",114],[11,"clone","","",114],[11,"clone_from","","",114],[11,"fmt","","",114],[11,"fmt","","",114],[11,"description","","",114],[11,"cause","","",114],[11,"fmt","","",115],[11,"clone","","",115],[11,"clone_from","","",115],[11,"eq","","",115],[11,"ne","","",115],[11,"ne","","",115],[11,"assert_receiver_is_total_eq","","",115],[11,"description","","",115],[11,"cause","","",115],[11,"fmt","","",115],[11,"clone","","",116],[11,"clone_from","","",116],[11,"next","","",116],[11,"size_hint","","",116],[11,"size_hint","","",116],[11,"next_back","","",116],[11,"clone","","",117],[11,"clone_from","","",117],[11,"next","","",117],[11,"size_hint","","",117],[11,"size_hint","","",117],[11,"next_back","","",117],[11,"clone","","",118],[11,"clone_from","","",118],[11,"next","","",118],[11,"size_hint","","",118],[11,"size_hint","","",118],[11,"next_back","","",118],[11,"len","","",118],[11,"len","","",118],[11,"clone","","",119],[11,"clone_from","","",119],[11,"call","","",119],[11,"clone","","",120],[11,"clone_from","","",120],[11,"clone","","",121],[11,"clone_from","","",121],[11,"next","","",120],[11,"size_hint","","",120],[11,"next_back","","",120],[11,"next","","",121],[11,"size_hint","","",121],[11,"clone","","",122],[11,"clone_from","","",122],[11,"clone","","",123],[11,"clone_from","","",123],[11,"clone","","",124],[11,"clone_from","","",124],[11,"clone","","",125],[11,"clone_from","","",125],[11,"clone","","",126],[11,"clone_from","","",126],[11,"next","","",125],[11,"size_hint","","",125],[11,"next","","",126],[11,"size_hint","","",126],[11,"clone","","",127],[11,"clone_from","","",127],[11,"next","","",127],[11,"size_hint","","",127],[11,"size_hint","","",127],[11,"next_back","","",127],[11,"clone","","",128],[11,"clone_from","","",128],[11,"next","","",128],[11,"size_hint","","",128],[11,"size_hint","","",128],[11,"next_back","","",128],[11,"clone","","",129],[11,"clone_from","","",129],[11,"next","","",129],[11,"size_hint","","",129],[11,"size_hint","","",129],[11,"clone","","",130],[11,"clone_from","","",130],[11,"next","","",130],[11,"size_hint","","",130],[11,"size_hint","","",130],[11,"next","","",131],[11,"size_hint","","",131],[11,"size_hint","","",131],[11,"next_back","","",131],[11,"next","","",132],[11,"size_hint","","",132],[11,"size_hint","","",132],[11,"next_back","","",132],[11,"new","core::hash::sip","Creates a new `SipHasher` with the two initial keys set to 0.",133],[11,"new_with_keys","","Creates a `SipHasher` that is keyed off the provided keys.",133],[11,"result","","Returns the computed hash.",133],[11,"write","","",133],[11,"reset","","",133],[11,"finish","","",133],[11,"clone","","",133],[11,"clone_from","","",133],[11,"default","","",133],[11,"hash","core::borrow","",43],[11,"eq","core::fmt::num","",134],[11,"ne","","",134],[11,"ne","","",134],[11,"clone","","",134],[11,"clone_from","","",134],[11,"eq","","",135],[11,"ne","","",135],[11,"ne","","",135],[11,"clone","","",135],[11,"clone_from","","",135],[11,"eq","","",136],[11,"ne","","",136],[11,"ne","","",136],[11,"clone","","",136],[11,"clone_from","","",136],[11,"eq","","",137],[11,"ne","","",137],[11,"ne","","",137],[11,"clone","","",137],[11,"clone_from","","",137],[11,"eq","","",138],[11,"ne","","",138],[11,"ne","","",138],[11,"clone","","",138],[11,"clone_from","","",138],[11,"eq","","",139],[11,"ne","","",139],[11,"ne","","",139],[11,"clone","","",139],[11,"clone_from","","",139],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"fmt","","",140],[11,"eq","core::fmt::rt::v1","",141],[11,"ne","","",141],[11,"ne","","",141],[11,"fmt","core::fmt","",142],[11,"fmt","","",143],[11,"fmt","","",143],[11,"fmt","","",142],[11,"fmt","core::cell","",44],[11,"fmt","","",46],[11,"fmt","","",48],[11,"fmt","","",50]],"paths":[[8,"PhfHash"],[3,"Map"],[3,"Entries"],[3,"Keys"],[3,"Values"],[3,"Set"],[3,"Iter"],[3,"OrderedMap"],[3,"Entries"],[3,"Keys"],[3,"Values"],[3,"OrderedSet"],[3,"Iter"],[3,"Formatter"],[4,"FpCategory"],[3,"ParseIntError"],[4,"IntErrorKind"],[3,"ParseFloatError"],[4,"FloatErrorKind"],[3,"NonZero"],[3,"Unique"],[3,"PhantomData"],[3,"CovariantType"],[3,"ContravariantType"],[3,"InvariantType"],[3,"CovariantLifetime"],[3,"ContravariantLifetime"],[3,"InvariantLifetime"],[3,"NoCopy"],[3,"Managed"],[3,"RangeFull"],[3,"Range"],[3,"RangeFrom"],[3,"RangeTo"],[4,"Ordering"],[8,"Any"],[3,"TypeId"],[3,"AtomicBool"],[3,"AtomicIsize"],[3,"AtomicUsize"],[3,"AtomicPtr"],[3,"AtomicInt"],[3,"AtomicUint"],[4,"Cow"],[3,"Cell"],[4,"BorrowState"],[3,"RefCell"],[3,"BorrowRef"],[3,"Ref"],[3,"BorrowRefMut"],[3,"RefMut"],[3,"UnsafeCell"],[3,"EscapeUnicode"],[4,"EscapeUnicodeState"],[3,"EscapeDefault"],[4,"EscapeDefaultState"],[3,"Finallyalizer"],[3,"Enumerate"],[3,"Inspect"],[3,"Rev"],[3,"Map"],[3,"Zip"],[4,"MinMaxResult"],[3,"Cloned"],[3,"Cycle"],[3,"Chain"],[3,"Filter"],[3,"FilterMap"],[3,"Peekable"],[3,"SkipWhile"],[3,"TakeWhile"],[3,"Skip"],[3,"Take"],[3,"Scan"],[3,"FlatMap"],[3,"Fuse"],[3,"Unfold"],[3,"Counter"],[3,"Range"],[3,"RangeInclusive"],[3,"RangeStep"],[3,"RangeStepInclusive"],[3,"Repeat"],[4,"Option"],[3,"Item"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[4,"Result"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"i8x16"],[3,"i16x8"],[3,"i32x4"],[3,"i64x2"],[3,"u8x16"],[3,"u16x8"],[3,"u32x4"],[3,"u64x2"],[3,"f32x4"],[3,"f64x2"],[3,"Iter"],[3,"IterMut"],[3,"Split"],[3,"SplitMut"],[3,"GenericSplitN"],[3,"SplitN"],[3,"RSplitN"],[3,"SplitNMut"],[3,"RSplitNMut"],[3,"Windows"],[3,"Chunks"],[3,"ChunksMut"],[3,"ParseBoolError"],[4,"Utf8Error"],[3,"Chars"],[3,"CharIndices"],[3,"Bytes"],[3,"BytesDeref"],[3,"CharSplits"],[3,"CharSplitsN"],[3,"NaiveSearcher"],[3,"TwoWaySearcher"],[4,"Searcher"],[3,"MatchIndices"],[3,"SplitStr"],[3,"Split"],[3,"SplitTerminator"],[3,"SplitN"],[3,"RSplitN"],[3,"Lines"],[3,"LinesAny"],[3,"SipHasher"],[3,"Binary"],[3,"Octal"],[3,"Decimal"],[3,"LowerHex"],[3,"UpperHex"],[3,"Radix"],[3,"RadixFmt"],[4,"Alignment"],[3,"Error"],[3,"Arguments"]]};
searchIndex['phf_macros'] = {"items":[[0,"","phf_macros","Compiler plugin for Rust-PHF"],[0,"util","",""],[3,"Entry","phf_macros::util",""],[12,"key_contents","","",0],[12,"key","","",0],[12,"value","","",0],[3,"HashState","",""],[4,"Key","",""],[13,"Str","","",1],[13,"Binary","","",1],[13,"Char","","",1],[13,"U8","","",1],[13,"I8","","",1],[13,"U16","","",1],[13,"I16","","",1],[13,"U32","","",1],[13,"I32","","",1],[13,"U64","","",1],[13,"I64","","",1],[13,"Bool","","",1],[5,"generate_hash","",""],[5,"try_generate_hash","",""],[5,"create_map","",""],[5,"create_set","",""],[5,"create_ordered_map","",""],[5,"create_ordered_set","",""],[11,"clone","","",1],[11,"eq","","",1],[11,"ne","","",1],[11,"hash","","",1],[11,"phf_hash","","",1]],"paths":[[3,"Entry"],[4,"Key"]]};

searchIndex['phf_shared'] = {"items":[[0,"","phf_shared",""],[5,"displace","",""],[8,"PhfHash","","A trait implemented by types which can be used in PHF data structures"],[10,"phf_hash","","Hashes the value of `self`, factoring in a seed",0]],"paths":[[8,"PhfHash"]]};

initSearch(searchIndex);
